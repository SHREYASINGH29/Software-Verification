procedure main()
{
var .I: int;
var .M: int;
var .J: int;
var .N: int;
var .K: int;
var .L: int;
var .C: int;
var .A: int;
var .B: int;
var .I1: int;
var .T1: int;
var .J1: int;
var .T2: int;
var .K1: int;
var .T3: int;
var .I2: int;
var .J2: int;
var .K2: int;
var __N1: int;
var __N2: int;
var __Data1StartI: [int]int;
var __Data2StartI: [int]int;
var __Data1SizeI: [int]int;
var __Data2SizeI: [int]int;
var __Data1StartJ: [int]int;
var __Data2StartJ: [int]int;
var __Data1SizeJ: [int]int;
var __Data2SizeJ: [int]int;
assume .M mod 1 == 0;
assume 1 <= .M div 2;
assume 1 > 0;
assume .N mod 1 == 0;
assume 1 <= .N div 2;
assume 1 > 0;
assume .L mod 1 == 0;
assume 1 <= .L div 2;
assume 1 > 0;
assume .M mod .T1 == 0;
assume .T1 <= .M div 2;
assume .T1 > 0;
assume .N mod .T2 == 0;
assume .T2 <= .N div 2;
assume .T2 > 0;
assume .L mod .T3 == 0;
assume .T3 <= .L div 2;
assume .T3 > 0;
assume (.I1 + .T1) mod 1 == 0;
assume 1 <= (.I1 + .T1) div 2;
assume 1 > 0;
assume (.J1 + .T2) mod 1 == 0;
assume 1 <= (.J1 + .T2) div 2;
assume 1 > 0;
assume (.K1 + .T3) mod 1 == 0;
assume 1 <= (.K1 + .T3) div 2;
assume 1 > 0;
.I := (.M - 0) div 1;
.J := (.N - 0) div 1;
.K := (.L - 0) div 1;
.I1 := (.M - 0) div .T1;
.J1 := (.N - 0) div .T2;
.K1 := (.L - 0) div .T3;
.I2 := ((.I1 + .T1) - .I1) div 1;
.J2 := ((.J1 + .T2) - .J1) div 1;
.K2 := ((.K1 + .T3) - .K1) div 1;
.I2 := .I2 * .I1;
.J2 := .J2 * .J1;
.K2 := .K2 * .K1;
__N1 := 0;
__N2 := 0;
assert (forall p: int :: ((exists i: int :: (i >= 0 && i < __N1) && (p >= __Data1StartI[i] && p < __Data1StartI[i] + __Data1SizeI[i])) ==> (exists j: int :: (j >= 0 && j < __N2) && (p >= __Data2StartI[j] && p < __Data2StartI[j] + __Data2SizeI[j]))));
assert (forall p: int :: ((exists j: int :: (j >= 0 && j < __N2) && (p >= __Data2StartI[j] && p < __Data2StartI[j] + __Data2SizeI[j])) ==> (exists i: int :: (i >= 0 && i < __N1) && (p >= __Data1StartI[i] && p < __Data1StartI[i] + __Data1SizeI[i]))));
assert .I == .I2;
assert .J == .J2;
assert .I == .I2;
assert .K == .K2;
assert .K == .K2;
assert .J == .J2;
assert 1 != 0 || .J == .K2 || .J == .J2 || .J == .I2;
assert 1 != 0 || .I == .K2 || .I == .J2 || .I == .I2;
assert 1 != 0 || .K == .K2 || .K == .J2 || .K == .I2;
assert 1  * .J * .I * .K == 1  * .K2 * .J2 * .I2;
}
